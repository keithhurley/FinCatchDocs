# Create Analysis

Analysis function calls are prefixed with "fca\_" and object names are prefixed with "fc\_"

Make sure to test each analysis function for:

-   Data selected by surveys only

-   Data selected by samples only

-   Data selected by both surveys and samples

-   Filters that return NO data

-   works for both grouped by survey and ungrouped analysis

    -   basic methodogy is to set surveyUid to "-1" if dataObject\$groupSurveys == FALSE

    -   may need to be careful when using "group by" as surveyUid will be dropped from data.frame but still be expected in subsequent code

Make sure to add to the list of analysis functions available in the package (found in inst folder)

### Steps:

1.  Create new r file names fc_analysisName.R (Easiest To Copy Existing Analysis and Modify)

2.  No library statements should be included in R file. Instead, they need to be included in the package DESCRIPTION file.

3.  Create/Modify the roxygen comments for procedure

4.  Name/Rename function. Analysis functions are prefixed with "fca\_" and the same base name as the "fc\_" file.

5.  All function calls require a FinCatch Data Object (fc_data) to be passed to an arguement named "myData"

6.  Check that fish (or Wq) samples exist in the current dataset.

7.  Set grouping variables. This allows for calculations to be grouped or NOT grouped by surveys in addition to whatever other fields are needed.

8.  This is determined by checking "myData\$groupBySurvey". A typical grouping block looks like:

`#set grouping vars to use or not use surveyUid`

`if (myData$groupSurveys == TRUE) {`

`myGroups <- c("surveyUid", "fishSpeciesCode")`

`} else {`

`myGroups <- c("fishSpeciesCode")`

`}`

-   If NOT grouped by survey, all surveyUid's need to be set to -1 before using the survey labeler functions

-   To group analysis calculations during analysis, use the dplyr verbs

    -   "group_by(across(all_of(myGroups))"

    -   add addition fields as necessary "group_by(across(all_of(myGroups), anotherFieldHere)"

8.  Write analysis code

    -   Always include Standard Error and Sample size (if appropriate), this allow users to calculate difference confidence intervals post hoc

    -   When including confidence intervals, include 95% and 80%

    -   Make sure to account for missing data in any input

9.  Label values like survey, sample, species, waterbody, etc.

    -   Labelers exist for samples and surveys (make sure surveyUid's are set to -1 if not grouping by survey

    -   Helper functions are available for coded values

10. Attach all results to an analysis object (either base or custom)

### Create Custom Analysis R6 Object

All analysis results are returned using R6 objects. This allows for consistent use and implementation of different analysis functions by parent applications and code. A base R6 object, "fc_base", provides all the basic functions and structure for FinCatch analysis objects. Custom objects can be created in the analysis files to allow customized output tables and plots and MUST inherit from the fc_base object.

Column names will often need to be altered to provided user friendly text in the outputs. In addition, sometimes valuable columns are dropped for display purposes. Both of these should be done in the analysis output object createTable functions, NOT in the analysis function itself or in the "results" property of the output table. This is to provide for consistency between analyses and is important for the download function of FinCatchRA.

Every effort is made to ensure tables produced by analysis objects work in both HTML (FinCatchRA), which allows more formatting options, and in LaTex , for PDF report generation. Basic table creation should happen by providing a "CreateTable" function. Any additional work needed for specific HTML or LaTex output should be included in overridden "CreateTableHtml" or "CreateTableLatex" functions....which otherwise just call and return the "CreateTable" function by default.

`fc_counts <- R6Class("fc_counts",`

`inherit = fc_base,`

`public = list(`

`createTable = function(mySurveyUid, myTableNumber) {`

`#if data was selected by samples onlyâ€¦all surveyUids will be blank`

`op <- NA`

`if (is.na(mySurveyUid) == TRUE) {`

`thisSurveyLabel <-`

`(self$results[[myTableNumber]] %>% filter(is.na(surveyUid)) %>% pull(surveyLabel))[[1]]`

`op <- self$results[[myTableNumber]] %>%`

`filter(is.na(surveyUid))`

`} else {`

`thisSurveyLabel <-`

`(self$results[[myTableNumber]] %>% filter(surveyUid == mySurveyUid) %>% pull(surveyLabel))[[1]]`

`op <-`

`self$results[[myTableNumber]] %>%`

`filter(surveyUid == mySurveyUid)`

`}`

`op <- op %>%`

`group_by(countSpeciesLabel, sampleLabel) %>%`

`summarise(FishCount = sum(FishCount, na.rm = TRUE)) %>%`

`mutate(countGenderLabel = "Total") %>%`

`bind_rows(self$results[[myTableNumber]]  %>%`

`filter(surveyUid == mySurveyUid)) %>%`

`arrange(countSpeciesLabel, sampleLabel, countGenderLabel) %>%`

`select(-countSpeciesCode,-countGenderCode,-sampleUid,-surveyLabel,-surveyUid) %>%`

`spread(countGenderLabel, FishCount, fill = 0) %>%`

`relocate("Total", .after = last_col()) %>%`

`# #group_by(across(all_of(c$groupByVars))) %>%`

`gt(rowname_col = colnames(self$results[[1]])[8]) %>%`

`tab_options(`

`row_group.background.color = self$groupHeaderBackgroundColor,`

`summary_row.background.color = self$groupSummaryBackgroundColor,`

`) %>%`

`#self$gt_table_options %>%`

`tab_header(title = md(self$tableTitle),`

`subtitle = thisSurveyLabel) %>%`

`summary_rows(`

`groups = TRUE,`

`columns = everything(),`

`#length(self$results[[1]])-3),#c(3, 4, 5, 6),#, 7),`

`fns = list("Total" = "sum"),`

`formatter = fmt_integer,`

`use_seps = TRUE,`

`missing_text = ""`

`) %>%`

`self$gtTheme()`

`return(op)`

`}`

`))`
